package com.wangfan.example.junit.externalservice;

public class information {


    /**
     * 单元测试一般有四大测试替身mock(伪造对象)、stub(测试桩)、spy(测试间谍)、fake(模拟对象)
     * 使用模拟对象是为了做到以下效果:
     *  .隔离被测试代码
     *  .加速执行测试
     *  .使执行变得确定
     *  .模拟特殊情况
     *  .访问隐藏信息
     */

    /**
     * 单元测试的牛肉汁去除
     * 单元测试往往可能需要根据多种情况，反复测试，提取重复的构建操作，让单元测试的每种情况看起来更单一，比对性更强。
     * 在线上生产环境出现问题时，或者情况过多时，能能帮助我们降低单元测试的阅读成本。
     */

    /**
     * 如果你关心交互，对于某种情况下，有明确的情况判断，可以选择mock
     */

    /**
     * spy是一种简单的mock，比如mock提供的功能太多，使得测试代码不够漂亮，spy可能更见的的完成需要，比如只是测试是否成功调用。
     */

    /**
     * 如果你想运行一个复杂场景，其中所依赖的服务或者组件无法供测试使用，而你怼所有交互打桩的快速尝试却戛然而止，
     * 或产出了难以维护的糟糕的测试代码，fake可能适合于当前情况。
     */

    /**
     * 如果你只关心写作对象向被测对象输送的相应，用桩stub就可以。其实模拟对象库可以完成stub的功能，而且让测试代码更简洁。
     */

    /**
     * 依赖注入并不意味着需要使用一个依赖注入框架，通过构造函数即可。
     */

    /**
     * 单元测试的坏味道
     * .测试范围过大，一个单元测试测试了太多的情况和逻辑，当我们发现失败后，不能快速定位问题和原因
     * .测试太过细碎或者信息不清楚，我们通过单元测试，无法明确知道本次测试期望的逻辑，需要重新阅读被测代码
     * .测试方法中的构造方法或者重复代码没有提取，重复测试的阅读成本太大
     * .测试中的魔法数字往往可能是致命的。
     * .测试方法不使用assert断言，而使用log或者System.out.println等方法，在出现问题后，重复测试困难加大
     * .单元测试中使用条件逻辑是维护负担，同时可能造成二次错误，应尽可能避免
     * .保证测试环境的正确初始化，使用@before或者@after去除上次或本次的测试遗留痕迹
     * .
     */
}
